# Monorepo

- 모노레포는 잘 정의된 관계를 가진 여러 개의 개별 프로젝트가 포함된 단일 리포지토리 입니다.

Micro Frontends 에서 Monorepo 가 필요한 이유.
개발 과정에서 여러 패키지들을 사용하고, 패키지는 바로 코드를 사용하는 방식이 아니라, 빌드 과정이 필요하므로, 다양한 문제가 발생할 수 있습니다.
레포지토리 내 워크스페이스에 대한 분석과 시각화 기능을 호라용하면 전체를 파악할 떄 효과적입니다.
스케폴딩이나 코드 공유 그리고 사용 제한 등의 관리에 수작업이 아니라 도구를 제공하면, 좀 더 편리합니다.

1. 여러 개의 프로젝트 (마이크로 앱) 모여 하나의 앱을 만들기 떄문에, 프로젝트는 여러 개가 필요합니다.
2. 프로젝트들이 잘 정의된 관계를 가지고 있습니다.
   - 공통으로 쓰는 코드들을 따로 뺴서 함꼐 사용하고
   - 이러한 패키지들이 의존 관계를 명확히 가지고 있어야 합니다.
   - 수정된 패키지가 어떤 마이크로 앱들에게 영향을 주는 지 확실히 알야아 힙니다.

Monorepo 의 장점

- 전체 히스토리가 한 번에 보입니다. -> `모든 프로젝트가 하나의 저장소에 있으므로, 전체 코드베이스의 변경 사항, 업데이트, 그리고 히스토리를 한 곳에서 볼 수 있습니다.`
- 기존 코드를 활용할 떄 드는 비용이 작습니다. -> `모듈화, 공통 코드를 모듈로 분리하고, 재사용하기 편리합니다.`
- 프로젝트를 새로 생성할 떄, 비용이 작습니다. -> `새 프로젝트를 실행할 떄, 기존의 설정, 도구, 라이브러리를 재사용하기 쉬움. 이미 검증괸 구조와 공통 설정을 사용할 수 있으므로, 초기 시간을 단축 가능.`
- 각 프로젝트마다 설정이 일관적이고 같은 DX 를 가질 수 있습니다. -> `프로젝트 간의 설정과 도구를 통일할 수 있는 환경을 제공합니다.`

Monorepo 의 단점

- 모노레포를 운영을 위한 추가적 학습이 필요, 모노레포 툴을 사용한다면, 툴에 대한 학습도 필요합니다.
- 상대적으로 의존성 연결이 쉽기 떄문에, 과도한 의존 관계가 나타날 수 있습니다.
- 하나의 CI를 구성할 수 있지만, 방법이 복잡할 수 있음.
- 많은 코드가 변경될 경우, 태스크 실행이 매우 느려질 수 있음.
- 저장소 자체가 빠르게 무거워질 수 있음.
- 모든 코드가 밀집되어 있어, 사소한 문제가 크게 확대될 가능성이 있습니다.

Module 로 연관 짓는다 라는 개념을 목적으로 하나의 레포에서 관리를 하면 Monorepo, 모듈마다 레포를 각자 가지고 관리하면 Polyrepo, Multirepo 라고 합니다.

Monorepo 구현 방식 결정.

- Local computation caching (속도) - 로컬 캐싱
  로컬 컴퓨터에서 이전에 수행된 작업의 결과를 캐싱 후, 같은 작업을 다시 수행 할 떄 시간을 절약 가능합니다.

- Distributed computation caching (속도) - 분산 캐싱
  여러 컴퓨터 간의 캐시를 공유, 네트워크 상의 다른 머신이 같은 작업을 빠르게 수행 할 수 있도록 합니다.

- Local task orchestration (속도) - 로컬 작업 오케스트레이션
  단일 시스템 내에서 다양한 작업(빌드, 테스트 등)을 조율하고 자동화는 프로세스 입니다.

- Distributed task execution (속도) - 분산 작업
  작업을 여러 컴퓨터 또는 서버에 분산시켜 실행함으로써, 작업 처리 속도를 향상시킵니다.

- Detecting affected packages (속도) - 변경 감지
  코드 변경이 특정 패키지에 영향을 미치는지 감지하는 기능으로, 필요한 부분만 재빌드하거나 테스트하여 시간을 절약합니다.

- Workspace analysis (분석) - 작업 영역 감지 및 분석
  전체 작업 영역을 분석하여 프로젝트의 구조와 종속성을 이해하고 최적화하는 과정입니다.

- Dependency graph visualization (분석) - 의존성 그래프 시각화
  프로젝트 내의 패키지 간 의존성을 그래픽으로 표현하여 복잡한 관계를 쉽게 이해할 수 있게 도와줍니다.

- Source code sharing (관리) - 소스 코드 조각 공유
  Monorepo 내에서 공통 코드 또는 유틸리티를 여러 프로젝트에서 재사용할 수 있도록 합니다.

- Code generation (관리) - 스케폴딩
  보일러플레이트 코드를 자동으로 생성하여 개발자의 수고를 덜어주는 기능입니다.

- Consistent tooling (관리) - 일관된 도구
  전체 저장소에서 동일한 빌드, 테스트, 배포 도구를 사용하여 일관된 개발 환경을 유지합니다. 이는 도구 관리와 사용자 경험을 단순화하고 표준화합니다.

- Project constraints and visibility (중속성 관계 저한)
  프로젝트 간의 종속성과 제약 조건을 설정하고, 이를 통해 프로젝트의 구조와 상호작용을 명확하게 관리할 수 있습니다.

## NX

여러 자바스크립트 및 타입스크립트 프로젝트의 관리를 통합하여 개발자의 생산성을 높이고,
CI(Continuous Integration, 지속적 통합)의 성능을 최적화하며,
코드 품질을 유지하는 데 초점을 맞춥니다.
nx 를 사용하면 여러 프로젝트를 쉽게 관리하고, 효율적으로 작업을 실행할 수 있습니다.

1. Run Tasks

nx 를 사용하여 개별 프로젝트 또는 전체 워크스페이스에서 작업을 실행할 수 있습니다.

- 단일 워크스페이스 태스크 실행 (my-app 워크스페이스 예시)

```javascript
nx build my-app
```

- 전체 워크스페이스들에 대한 태스크 실행 (build 예시)

```javascript
nx run-many --all --target=build
```

- 전체 워크스페이스들에 대한 여러 태스크 실행 (build, test 예시)

```javascript
nx run-many --all --target=build,test
```

2. Cache Task Results

nx 는 태스크 실행 결과를 캐싱하여, 동일한 입력에 대해 태스크를 재실행할 필요가 없도록 합니다. 이는 빌드 시간을 크게 단축시킵니다.
nx.json / project.json / package.json 등을 이용 해 설정 할 수 있음.

3. Use Remote Caching

nx Cloud 를 사용하면 캐싱 결과를 원격으로 저장하고 공유할 수 있어, 팀원 간에 작업 실행 시간을 줄일 수 있습니다.

```javascript
nx connect-to-nx-cloud
```

4. Distribution Task Execution

nx Cloud를 활용하면 CI 환경에서 작업 실행을 병렬화하여 성능을 개선할 수 있습니다.
nx Cloud 에 연결 후, (nx connect-to-nx-cloud)
CI 에서 DTE 를 활성화 합니다. (nx generate @nrwl/workspace:ci-workflow --ci=github)

```javascript
nx generate @nrwl/workspace:ci-workflow --ci=github
```

5. Automate Updating Dependencies

사용 중인 패키지 버전을 자동으로 업데이트하고, 필요한 경우 설정이나 소스 코드를 마이그레이션할 수 있습니다.

6. Enforce Module Boundaries

nx 는 코드 분석을 통해 프로젝트 간 잘 정의된 API에만 의존하도록 강제하고, 선언적으로 의존성 규칙을 설정할 수 있게 해줍니다. 이는 Lint 규칙을 통해 구현됩니다.
nx 를 사용하면 모노레포 관리가 훨씬 간편해지며, 이러한 기능을 통해 프로젝트의 구조를 명확히 하고, 팀의 작업 흐름을 효율적으로 만들 수 있습니다.

## Rush

Rush 는 monorepo 에서 프로젝트나, 패키지를 효율적으로 관리 해 주는 도구 입니다.

1. 의존성 충돌 : 각 프로젝트에 같은 라이브러리이지만, 서로 다른 버전의 라이브러리가 존재 할 수 있음. 예로 들면 패키지안에 A 패키지는 react@16, B 패키지는 react@14 을 사용 할 수 있습니다.
   이런 문제가 발생 할 경우, 두 프로젝트가 서로 호환이 되지 않아, 의존성 충돌이 발생할 수 있습니다.
   pnpm 에서도 하드 링크와, 심볼릭 링크를 사용 해 의존성 충돌 문제를 해결 하지만, rush 는 pnpm 과 같은 패키지 매니저가 제공하는 기능 이상의 추가적인 이점을 제공 해 줍니다.
2. 통합 빌드 및 테스트 파이프라인 : Rush 는 변경된 패키지만 빌드하고, 테스트하는 `Incremental Builds` 기능뿐만 아니라, 전체 Monorepo 에 걸쳐 일관된 빌드, 테스트, 배포 파이프라인을 설정할 수 있게 해줍니다.
3. 멀티 패키지 관리 : pnpm 은 좀 더 의존성 관리에 초점을 맞췄지만, rush 는 여러 패키지 의존성, 버전 관리, 배포를 동시에 처리할 수 있는 기능을 제공 해 줍니다.

- rushx 사용: 개별 패키지 내에서 커스텀 스크립트를 실행할 때 사용합니다. 예를 들어, 특정 패키지에 대한 빌드나 테스트 스크립트를 실행할 수 있습니다.
- rush 사용: Monorepo 내의 모든 패키지에 걸쳐 스크립트를 실행할 때 사용합니다. 이를 통해 전체 프로젝트의 빌드, 테스트, 업데이트 등을 한 번에 관리할 수 있습니다.

## TurboRepo

모노레포 환경에서 빠르고 쉽게 빌드 시간을 단축 시킬 수 있음.
CPU 코어를 활용해 벙렬로 실행해서, 빌드 프로세스 속도를 높일 수 있음. -> 로컬 캐시, 리모트 캐시, 병렬 실행 등 쉽게 사용 가능.
yarn, npm workspace 에서도 사용 가능하지만, pnpm 과 같이 사용하길 권장합니다.

정리 해 보자면 TurboRepo 에서는 build 을 할 떄, 캐시로 계속 축적되어서, 수정되지 않은 패키지들은 캐시로 축적되고, 수정 된 것들만 빌드가 되는 프로세스여서,
빌드 시간을 줄일 수 있습니다.
